{"uid":"f7c1c2900c479ace","name":"test24_live_square","fullName":"tests.test_case.test_try#test24_live_square","historyId":"7860ecbf178b777867641083c197e989","time":{"start":1662544443560,"stop":1662544449649,"duration":6089},"description":"用例开始时间:2022-09-07 17:54:03.560120","descriptionHtml":"<p>用例开始时间:2022-09-07 17:54:03.560120</p>\n","status":"broken","statusMessage":"Exception: 页面中未能找到 [打开我的页]","statusTrace":"self = <base.action.ElementActions object at 0x0000026B060FACB0>\nlocator = {'element': 'cn.missevan:id/nav_icon_mine', 'method': 'click', 'name': '打开我的页', 'time': 5, ...}\nis_need_displayed = True\n\n    def _find_element(self, locator, is_need_displayed=True):\n        \"\"\" ：单个元素,如果有多个返回第一个\n        :param locator: 定位器\n        :param is_need_displayed: 是否需要定位的元素必须展示\n        :return:\n        :raises:NotFoundElementError\n        \"\"\"\n    \n        with allure.step(\"检查：'{0}'\".format(locator.get('name'))):\n            try:\n                if is_need_displayed:\n>                   return WebDriverWait(self.driver, locator['time']).until(\n                        lambda driver: self._get_element_by_type(driver, locator), '查找元素'.format(locator.get('name')))\n\nbase\\action.py:331: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <selenium.webdriver.support.wait.WebDriverWait (session=\"6bbc3eee-3598-438f-8ad8-4748a2d053cf\")>\nmethod = <function ElementActions._find_element.<locals>.<lambda> at 0x0000026B06161C60>\nmessage = '查找元素'\n\n    def until(self, method, message=''):\n        \"\"\"Calls the method provided with the driver as an argument until the \\\n        return value does not evaluate to ``False``.\n    \n        :param method: callable(WebDriver)\n        :param message: optional message for :exc:`TimeoutException`\n        :returns: the result of the last call to `method`\n        :raises: :exc:`selenium.common.exceptions.TimeoutException` if timeout occurs\n        \"\"\"\n        screen = None\n        stacktrace = None\n    \n        end_time = time.time() + self._timeout\n        while True:\n            try:\n                value = method(self._driver)\n                if value:\n                    return value\n            except InvalidSelectorException as e:\n                raise e\n            except self._ignored_exceptions as exc:\n                screen = getattr(exc, 'screen', None)\n                stacktrace = getattr(exc, 'stacktrace', None)\n            time.sleep(self._poll)\n            if time.time() > end_time:\n                break\n>       raise TimeoutException(message, screen, stacktrace)\nE       selenium.common.exceptions.TimeoutException: Message: 查找元素\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\selenium\\webdriver\\support\\wait.py:89: TimeoutException\n\nDuring handling of the above exception, another exception occurred:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_runtest_hook.<locals>.<lambda> at 0x0000026B06098C10>\nwhen = 'call'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: \"Callable[[], TResult]\",\n        when: \"Literal['collect', 'setup', 'call', 'teardown']\",\n        reraise: Optional[\n            Union[Type[BaseException], Tuple[Type[BaseException], ...]]\n        ] = None,\n    ) -> \"CallInfo[TResult]\":\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        start = timing.time()\n        precise_start = timing.perf_counter()\n        try:\n>           result: Optional[TResult] = func()\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\_pytest\\runner.py:338: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise\n    )\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\_pytest\\runner.py:259: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <_HookCaller 'pytest_runtest_call'>, args = ()\nkwargs = {'item': <YamlTest test24_live_square>}, argname = 'item'\nfirstresult = False\n\n    def __call__(self, *args, **kwargs):\n        if args:\n            raise TypeError(\"hook calling supports only keyword arguments\")\n        assert not self.is_historic()\n    \n        # This is written to avoid expensive operations when not needed.\n        if self.spec:\n            for argname in self.spec.argnames:\n                if argname not in kwargs:\n                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())\n                    warnings.warn(\n                        \"Argument(s) {} which are declared in the hookspec \"\n                        \"can not be found in this hook call\".format(notincall),\n                        stacklevel=2,\n                    )\n                    break\n    \n            firstresult = self.spec.opts.get(\"firstresult\")\n        else:\n            firstresult = False\n    \n>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pluggy\\_hooks.py:265: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <_pytest.config.PytestPluginManager object at 0x0000026B05A96C80>\nhook_name = 'pytest_runtest_call'\nmethods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\\\Users\\\\任\\\\AppData\\\\Local\\\\Programs\\\\Python\\...0>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x0000026B06062CE0>>, ...]\nkwargs = {'item': <YamlTest test24_live_square>}, firstresult = False\n\n    def _hookexec(self, hook_name, methods, kwargs, firstresult):\n        # called from all hookcaller instances.\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\n>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pluggy\\_manager.py:80: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\\\Users\\\\任\\\\AppData\\\\Local\\\\Programs\\\\Python\\...0>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x0000026B06062CE0>>, ...]\ncaller_kwargs = {'item': <YamlTest test24_live_square>}, firstresult = False\n\n    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from _HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results = []\n        excinfo = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n    \n                    if hook_impl.hookwrapper:\n                        try:\n                            gen = hook_impl.function(*args)\n                            next(gen)  # first yield\n                            teardowns.append(gen)\n                        except StopIteration:\n                            _raise_wrapfail(gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException:\n                excinfo = sys.exc_info()\n        finally:\n            if firstresult:  # first result hooks return a single value\n                outcome = _Result(results[0] if results else None, excinfo)\n            else:\n                outcome = _Result(results, excinfo)\n    \n            # run all wrapper post-yield blocks\n            for gen in reversed(teardowns):\n                try:\n                    gen.send(outcome)\n                    _raise_wrapfail(gen, \"has second yield\")\n                except StopIteration:\n                    pass\n    \n>           return outcome.get_result()\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pluggy\\_callers.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pluggy._result._Result object at 0x0000026B060FB460>\n\n    def get_result(self):\n        \"\"\"Get the result(s) for this hook call.\n    \n        If the hook was marked as a ``firstresult`` only a single value\n        will be returned otherwise a list of results.\n        \"\"\"\n        __tracebackhide__ = True\n        if self._excinfo is None:\n            return self._result\n        else:\n            ex = self._excinfo\n>           raise ex[1].with_traceback(ex[2])\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pluggy\\_result.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\\\Users\\\\任\\\\AppData\\\\Local\\\\Programs\\\\Python\\...0>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x0000026B06062CE0>>, ...]\ncaller_kwargs = {'item': <YamlTest test24_live_square>}, firstresult = False\n\n    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from _HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results = []\n        excinfo = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n    \n                    if hook_impl.hookwrapper:\n                        try:\n                            gen = hook_impl.function(*args)\n                            next(gen)  # first yield\n                            teardowns.append(gen)\n                        except StopIteration:\n                            _raise_wrapfail(gen, \"did not yield\")\n                    else:\n>                       res = hook_impl.function(*args)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pluggy\\_callers.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nitem = <YamlTest test24_live_square>\n\n    def pytest_runtest_call(item: Item) -> None:\n        _update_current_test_var(item, \"call\")\n        try:\n            del sys.last_type\n            del sys.last_value\n            del sys.last_traceback\n        except AttributeError:\n            pass\n        try:\n            item.runtest()\n        except Exception as e:\n            # Store trace info to allow postmortem debugging\n            sys.last_type = type(e)\n            sys.last_value = e\n            assert e.__traceback__ is not None\n            # Skip *this* frame\n            sys.last_traceback = e.__traceback__.tb_next\n>           raise e\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\_pytest\\runner.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nitem = <YamlTest test24_live_square>\n\n    def pytest_runtest_call(item: Item) -> None:\n        _update_current_test_var(item, \"call\")\n        try:\n            del sys.last_type\n            del sys.last_value\n            del sys.last_traceback\n        except AttributeError:\n            pass\n        try:\n>           item.runtest()\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\_pytest\\runner.py:166: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <YamlTest test24_live_square>\n\n    def runtest(self):\n        # 运行用例\n        for self.locator in self.values:\n            self.locator['time'] = 5\n            is_displayed = True\n            if not self.locator.get('is_displayed'):\n                is_displayed = False if str(self.locator.get('is_displayed')).lower() == 'false' else True\n            try:\n                if self.locator.get('element'):\n                    response = self.Action.__getattribute__(self.locator.get('method'))(yamldict(self.locator))\n                else:\n                    response = self.Action.__getattribute__(self.locator.get('method'))()\n                if not self.locator.get('is_not_exist'):\n                    self.assert_response(response, self.locator)\n                else:\n                    self.assert_no_response(response, self.locator)\n            except Exception as E:\n                if is_displayed:\n>                   raise E\n\ntests\\conftest.py:110: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <YamlTest test24_live_square>\n\n    def runtest(self):\n        # 运行用例\n        for self.locator in self.values:\n            self.locator['time'] = 5\n            is_displayed = True\n            if not self.locator.get('is_displayed'):\n                is_displayed = False if str(self.locator.get('is_displayed')).lower() == 'false' else True\n            try:\n                if self.locator.get('element'):\n>                   response = self.Action.__getattribute__(self.locator.get('method'))(yamldict(self.locator))\n\ntests\\conftest.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <base.action.ElementActions object at 0x0000026B060FACB0>\nlocator = {'element': 'cn.missevan:id/nav_icon_mine', 'method': 'click', 'name': '打开我的页', 'time': 5, ...}\ncount = 1\n\n    def click(self, locator, count=1):\n        \"\"\"基础的点击事件\n        :param locator: 定位器\n        :param count: 点击次数\n        \"\"\"\n        if locator.get('index'):\n            el = self._find_elements(locator)[locator['index']]\n        else:\n>           el = self._find_element(locator)\n\nbase\\action.py:153: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <base.action.ElementActions object at 0x0000026B060FACB0>\nlocator = {'element': 'cn.missevan:id/nav_icon_mine', 'method': 'click', 'name': '打开我的页', 'time': 5, ...}\nis_need_displayed = True\n\n    def _find_element(self, locator, is_need_displayed=True):\n        \"\"\" ：单个元素,如果有多个返回第一个\n        :param locator: 定位器\n        :param is_need_displayed: 是否需要定位的元素必须展示\n        :return:\n        :raises:NotFoundElementError\n        \"\"\"\n    \n        with allure.step(\"检查：'{0}'\".format(locator.get('name'))):\n            try:\n                if is_need_displayed:\n                    return WebDriverWait(self.driver, locator['time']).until(\n                        lambda driver: self._get_element_by_type(driver, locator), '查找元素'.format(locator.get('name')))\n    \n            except Exception as e:\n                print(e)\n                L.e(\"页面中未能找到 %s 元素\" % locator)\n>               raise Exception(\"页面中未能找到 [%s]\" % locator.get('name'))\nE               Exception: 页面中未能找到 [打开我的页]\n\nbase\\action.py:337: Exception","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[],"testStage":{"description":"用例开始时间:2022-09-07 17:54:03.560120","status":"broken","statusMessage":"Exception: 页面中未能找到 [打开我的页]","statusTrace":"self = <base.action.ElementActions object at 0x0000026B060FACB0>\nlocator = {'element': 'cn.missevan:id/nav_icon_mine', 'method': 'click', 'name': '打开我的页', 'time': 5, ...}\nis_need_displayed = True\n\n    def _find_element(self, locator, is_need_displayed=True):\n        \"\"\" ：单个元素,如果有多个返回第一个\n        :param locator: 定位器\n        :param is_need_displayed: 是否需要定位的元素必须展示\n        :return:\n        :raises:NotFoundElementError\n        \"\"\"\n    \n        with allure.step(\"检查：'{0}'\".format(locator.get('name'))):\n            try:\n                if is_need_displayed:\n>                   return WebDriverWait(self.driver, locator['time']).until(\n                        lambda driver: self._get_element_by_type(driver, locator), '查找元素'.format(locator.get('name')))\n\nbase\\action.py:331: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <selenium.webdriver.support.wait.WebDriverWait (session=\"6bbc3eee-3598-438f-8ad8-4748a2d053cf\")>\nmethod = <function ElementActions._find_element.<locals>.<lambda> at 0x0000026B06161C60>\nmessage = '查找元素'\n\n    def until(self, method, message=''):\n        \"\"\"Calls the method provided with the driver as an argument until the \\\n        return value does not evaluate to ``False``.\n    \n        :param method: callable(WebDriver)\n        :param message: optional message for :exc:`TimeoutException`\n        :returns: the result of the last call to `method`\n        :raises: :exc:`selenium.common.exceptions.TimeoutException` if timeout occurs\n        \"\"\"\n        screen = None\n        stacktrace = None\n    \n        end_time = time.time() + self._timeout\n        while True:\n            try:\n                value = method(self._driver)\n                if value:\n                    return value\n            except InvalidSelectorException as e:\n                raise e\n            except self._ignored_exceptions as exc:\n                screen = getattr(exc, 'screen', None)\n                stacktrace = getattr(exc, 'stacktrace', None)\n            time.sleep(self._poll)\n            if time.time() > end_time:\n                break\n>       raise TimeoutException(message, screen, stacktrace)\nE       selenium.common.exceptions.TimeoutException: Message: 查找元素\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\selenium\\webdriver\\support\\wait.py:89: TimeoutException\n\nDuring handling of the above exception, another exception occurred:\n\ncls = <class '_pytest.runner.CallInfo'>\nfunc = <function call_runtest_hook.<locals>.<lambda> at 0x0000026B06098C10>\nwhen = 'call'\nreraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)\n\n    @classmethod\n    def from_call(\n        cls,\n        func: \"Callable[[], TResult]\",\n        when: \"Literal['collect', 'setup', 'call', 'teardown']\",\n        reraise: Optional[\n            Union[Type[BaseException], Tuple[Type[BaseException], ...]]\n        ] = None,\n    ) -> \"CallInfo[TResult]\":\n        \"\"\"Call func, wrapping the result in a CallInfo.\n    \n        :param func:\n            The function to call. Called without arguments.\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        start = timing.time()\n        precise_start = timing.perf_counter()\n        try:\n>           result: Optional[TResult] = func()\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\_pytest\\runner.py:338: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise\n    )\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\_pytest\\runner.py:259: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <_HookCaller 'pytest_runtest_call'>, args = ()\nkwargs = {'item': <YamlTest test24_live_square>}, argname = 'item'\nfirstresult = False\n\n    def __call__(self, *args, **kwargs):\n        if args:\n            raise TypeError(\"hook calling supports only keyword arguments\")\n        assert not self.is_historic()\n    \n        # This is written to avoid expensive operations when not needed.\n        if self.spec:\n            for argname in self.spec.argnames:\n                if argname not in kwargs:\n                    notincall = tuple(set(self.spec.argnames) - kwargs.keys())\n                    warnings.warn(\n                        \"Argument(s) {} which are declared in the hookspec \"\n                        \"can not be found in this hook call\".format(notincall),\n                        stacklevel=2,\n                    )\n                    break\n    \n            firstresult = self.spec.opts.get(\"firstresult\")\n        else:\n            firstresult = False\n    \n>       return self._hookexec(self.name, self.get_hookimpls(), kwargs, firstresult)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pluggy\\_hooks.py:265: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <_pytest.config.PytestPluginManager object at 0x0000026B05A96C80>\nhook_name = 'pytest_runtest_call'\nmethods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\\\Users\\\\任\\\\AppData\\\\Local\\\\Programs\\\\Python\\...0>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x0000026B06062CE0>>, ...]\nkwargs = {'item': <YamlTest test24_live_square>}, firstresult = False\n\n    def _hookexec(self, hook_name, methods, kwargs, firstresult):\n        # called from all hookcaller instances.\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\n>       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pluggy\\_manager.py:80: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\\\Users\\\\任\\\\AppData\\\\Local\\\\Programs\\\\Python\\...0>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x0000026B06062CE0>>, ...]\ncaller_kwargs = {'item': <YamlTest test24_live_square>}, firstresult = False\n\n    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from _HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results = []\n        excinfo = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n    \n                    if hook_impl.hookwrapper:\n                        try:\n                            gen = hook_impl.function(*args)\n                            next(gen)  # first yield\n                            teardowns.append(gen)\n                        except StopIteration:\n                            _raise_wrapfail(gen, \"did not yield\")\n                    else:\n                        res = hook_impl.function(*args)\n                        if res is not None:\n                            results.append(res)\n                            if firstresult:  # halt further impl calls\n                                break\n            except BaseException:\n                excinfo = sys.exc_info()\n        finally:\n            if firstresult:  # first result hooks return a single value\n                outcome = _Result(results[0] if results else None, excinfo)\n            else:\n                outcome = _Result(results, excinfo)\n    \n            # run all wrapper post-yield blocks\n            for gen in reversed(teardowns):\n                try:\n                    gen.send(outcome)\n                    _raise_wrapfail(gen, \"has second yield\")\n                except StopIteration:\n                    pass\n    \n>           return outcome.get_result()\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pluggy\\_callers.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pluggy._result._Result object at 0x0000026B060FB460>\n\n    def get_result(self):\n        \"\"\"Get the result(s) for this hook call.\n    \n        If the hook was marked as a ``firstresult`` only a single value\n        will be returned otherwise a list of results.\n        \"\"\"\n        __tracebackhide__ = True\n        if self._excinfo is None:\n            return self._result\n        else:\n            ex = self._excinfo\n>           raise ex[1].with_traceback(ex[2])\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pluggy\\_result.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nhook_name = 'pytest_runtest_call'\nhook_impls = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\\\Users\\\\任\\\\AppData\\\\Local\\\\Programs\\\\Python\\...0>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x0000026B06062CE0>>, ...]\ncaller_kwargs = {'item': <YamlTest test24_live_square>}, firstresult = False\n\n    def _multicall(hook_name, hook_impls, caller_kwargs, firstresult):\n        \"\"\"Execute a call into multiple python functions/methods and return the\n        result(s).\n    \n        ``caller_kwargs`` comes from _HookCaller.__call__().\n        \"\"\"\n        __tracebackhide__ = True\n        results = []\n        excinfo = None\n        try:  # run impl and wrapper setup functions in a loop\n            teardowns = []\n            try:\n                for hook_impl in reversed(hook_impls):\n                    try:\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\n                    except KeyError:\n                        for argname in hook_impl.argnames:\n                            if argname not in caller_kwargs:\n                                raise HookCallError(\n                                    f\"hook call must provide argument {argname!r}\"\n                                )\n    \n                    if hook_impl.hookwrapper:\n                        try:\n                            gen = hook_impl.function(*args)\n                            next(gen)  # first yield\n                            teardowns.append(gen)\n                        except StopIteration:\n                            _raise_wrapfail(gen, \"did not yield\")\n                    else:\n>                       res = hook_impl.function(*args)\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pluggy\\_callers.py:39: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nitem = <YamlTest test24_live_square>\n\n    def pytest_runtest_call(item: Item) -> None:\n        _update_current_test_var(item, \"call\")\n        try:\n            del sys.last_type\n            del sys.last_value\n            del sys.last_traceback\n        except AttributeError:\n            pass\n        try:\n            item.runtest()\n        except Exception as e:\n            # Store trace info to allow postmortem debugging\n            sys.last_type = type(e)\n            sys.last_value = e\n            assert e.__traceback__ is not None\n            # Skip *this* frame\n            sys.last_traceback = e.__traceback__.tb_next\n>           raise e\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\_pytest\\runner.py:174: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nitem = <YamlTest test24_live_square>\n\n    def pytest_runtest_call(item: Item) -> None:\n        _update_current_test_var(item, \"call\")\n        try:\n            del sys.last_type\n            del sys.last_value\n            del sys.last_traceback\n        except AttributeError:\n            pass\n        try:\n>           item.runtest()\n\n..\\..\\..\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\_pytest\\runner.py:166: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <YamlTest test24_live_square>\n\n    def runtest(self):\n        # 运行用例\n        for self.locator in self.values:\n            self.locator['time'] = 5\n            is_displayed = True\n            if not self.locator.get('is_displayed'):\n                is_displayed = False if str(self.locator.get('is_displayed')).lower() == 'false' else True\n            try:\n                if self.locator.get('element'):\n                    response = self.Action.__getattribute__(self.locator.get('method'))(yamldict(self.locator))\n                else:\n                    response = self.Action.__getattribute__(self.locator.get('method'))()\n                if not self.locator.get('is_not_exist'):\n                    self.assert_response(response, self.locator)\n                else:\n                    self.assert_no_response(response, self.locator)\n            except Exception as E:\n                if is_displayed:\n>                   raise E\n\ntests\\conftest.py:110: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <YamlTest test24_live_square>\n\n    def runtest(self):\n        # 运行用例\n        for self.locator in self.values:\n            self.locator['time'] = 5\n            is_displayed = True\n            if not self.locator.get('is_displayed'):\n                is_displayed = False if str(self.locator.get('is_displayed')).lower() == 'false' else True\n            try:\n                if self.locator.get('element'):\n>                   response = self.Action.__getattribute__(self.locator.get('method'))(yamldict(self.locator))\n\ntests\\conftest.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <base.action.ElementActions object at 0x0000026B060FACB0>\nlocator = {'element': 'cn.missevan:id/nav_icon_mine', 'method': 'click', 'name': '打开我的页', 'time': 5, ...}\ncount = 1\n\n    def click(self, locator, count=1):\n        \"\"\"基础的点击事件\n        :param locator: 定位器\n        :param count: 点击次数\n        \"\"\"\n        if locator.get('index'):\n            el = self._find_elements(locator)[locator['index']]\n        else:\n>           el = self._find_element(locator)\n\nbase\\action.py:153: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <base.action.ElementActions object at 0x0000026B060FACB0>\nlocator = {'element': 'cn.missevan:id/nav_icon_mine', 'method': 'click', 'name': '打开我的页', 'time': 5, ...}\nis_need_displayed = True\n\n    def _find_element(self, locator, is_need_displayed=True):\n        \"\"\" ：单个元素,如果有多个返回第一个\n        :param locator: 定位器\n        :param is_need_displayed: 是否需要定位的元素必须展示\n        :return:\n        :raises:NotFoundElementError\n        \"\"\"\n    \n        with allure.step(\"检查：'{0}'\".format(locator.get('name'))):\n            try:\n                if is_need_displayed:\n                    return WebDriverWait(self.driver, locator['time']).until(\n                        lambda driver: self._get_element_by_type(driver, locator), '查找元素'.format(locator.get('name')))\n    \n            except Exception as e:\n                print(e)\n                L.e(\"页面中未能找到 %s 元素\" % locator)\n>               raise Exception(\"页面中未能找到 [%s]\" % locator.get('name'))\nE               Exception: 页面中未能找到 [打开我的页]\n\nbase\\action.py:337: Exception","steps":[{"name":"检查：'打开我的页'","time":{"start":1662544443810,"stop":1662544449644,"duration":5834},"status":"broken","statusMessage":"Exception: 页面中未能找到 [打开我的页]\n","statusTrace":"  File \"C:\\Users\\任\\Desktop\\appui\\App_ui\\base\\action.py\", line 337, in _find_element\n    raise Exception(\"页面中未能找到 [%s]\" % locator.get('name'))\n","steps":[],"attachments":[],"parameters":[],"attachmentsCount":0,"shouldDisplayMessage":true,"stepsCount":0,"hasContent":true}],"attachments":[{"uid":"7fde3aa24ce7654","name":"失败截图","source":"7fde3aa24ce7654.png","type":"image/png","size":534477},{"uid":"4da7b8a26d3a2ccc","name":"APPlog","source":"4da7b8a26d3a2ccc.txt","type":"text/plain","size":1228612},{"uid":"126c0891055b9cb4","name":"stdout","source":"126c0891055b9cb4.txt","type":"text/plain","size":609}],"parameters":[],"attachmentsCount":3,"shouldDisplayMessage":true,"stepsCount":1,"hasContent":true},"afterStages":[],"labels":[{"name":"parentSuite","value":"tests.test_case"},{"name":"suite","value":"test_try"},{"name":"host","value":"DESKTOP-PVD568M"},{"name":"thread","value":"15940-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.test_case.test_try"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":true,"retry":true,"extra":{"categories":[],"tags":[]},"source":"f7c1c2900c479ace.json","parameterValues":[]}